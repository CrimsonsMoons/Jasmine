-- Robust Unvault runner (LocalScript)
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local LocalPlayer = Players.LocalPlayer
assert(LocalPlayer, "LocalPlayer not available. Run as a LocalScript (client).")

-- Path to the UI list
local LIST = LocalPlayer:WaitForChild("PlayerGui", 9e9)
    :WaitForChild("Menus", 9e9)
    :WaitForChild("ItemVault", 9e9)
    :WaitForChild("Content", 9e9)
    :WaitForChild("List", 9e9)

-- Remote config (change index if needed)
local REMOTE_INDEX = 54
local ACTION = "Unvault"

local COMM = ReplicatedStorage:WaitForChild("Communication", 9e9)
local EVENTS = COMM:WaitForChild("Events", 9e9)

-- find remote safely (tries raw children first, then only RemoteEvent/Function list)
local function findRemoteByIndex(index)
    local children = EVENTS:GetChildren()
    if children[index] then return children[index] end
    local rems = {}
    for _,v in ipairs(children) do
        if v:IsA("RemoteEvent") or v:IsA("RemoteFunction") then
            table.insert(rems, v)
        end
    end
    return rems[index]
end

local remote = findRemoteByIndex(REMOTE_INDEX)
if not remote then
    warn(("Remote not found at index %d (Events count = %d)."):format(REMOTE_INDEX, #EVENTS:GetChildren()))
    -- print events indices for debugging and stop
    for i,v in ipairs(EVENTS:GetChildren()) do
        print(i, v.Name, v.ClassName)
    end
    return
end
print("Using remote:", remote:GetFullName(), "Class:", remote.ClassName)

-- Try to extract a UUID string from the UI item (flexible)
local function extractUUIDFromItem(item)
    -- 1) name looks like {uuid}
    if item.Name and item.Name:match("^%b{}$") then
        return item.Name
    end
    -- 2) attributes
    for _,attr in ipairs({"UUID","Id","ItemId","ID"}) do
        local a = item:GetAttribute(attr)
        if a and tostring(a) ~= "" then
            local s = tostring(a)
            if not s:match("^%b{}$") then s = "{"..s.."}" end
            return s
        end
    end
    -- 3) descendant text (TextLabel/TextButton/TextBox)
    for _,desc in ipairs(item:GetDescendants()) do
        if desc:IsA("TextLabel") or desc:IsA("TextButton") or desc:IsA("TextBox") then
            local t = tostring(desc.Text or "")
            -- prefer {xxx-xxx...} or pick hyphenated UUID-like pattern
            local found = t:match("(%b{})") or t:match("([%w%-]+%-%w+%-%w+%-%w+%-%w+)")
            if found then
                if not found:match("^%b{}$") then found = "{"..found.."}" end
                return found
            end
        end
    end
    return nil
end

-- wait until the list is "stable" (count not changing) or timeout
local function waitForStableChildren(parent, stableSec, timeout)
    stableSec = stableSec or 1
    timeout = timeout or 30
    local start = os.clock()
    local lastCount = #parent:GetChildren()
    local stableStart = nil
    while true do
        if os.clock() - start > timeout then
            return false, lastCount
        end
        local count = #parent:GetChildren()
        if count > 0 and count == lastCount then
            if not stableStart then stableStart = os.clock() end
            if os.clock() - stableStart >= stableSec then
                return true, count
            end
        else
            stableStart = nil
            lastCount = count
        end
        task.wait(0.15)
    end
end

print("Waiting for ItemVault list to fill and stabilize...")
local ok, count = waitForStableChildren(LIST, 1.0, 30)
if not ok then
    warn("List did not stabilize within timeout. Continuing with current children count:", count)
end

-- collect UUIDs
local uuids = {}
for _,child in ipairs(LIST:GetChildren()) do
    local uid = extractUUIDFromItem(child)
    if uid then
        table.insert(uuids, uid)
    else
        warn("No UUID extracted from:", child:GetFullName(), " name:", child.Name)
    end
end

if #uuids == 0 then
    warn("No UUIDs found. Dumping list children for debugging:")
    for i,c in ipairs(LIST:GetChildren()) do
        print(i, c.Name)
        -- show text children (helpful to see where the id is)
        for _,d in ipairs(c:GetDescendants()) do
            if d:IsA("TextLabel") or d:IsA("TextButton") or d:IsA("TextBox") then
                print("   Text child:", d:GetFullName(), "=>", d.Text)
            end
        end
    end
    return
end

print(("Found %d UUID(s). Beginning to send %q for each."):format(#uuids, ACTION))

for i,uid in ipairs(uuids) do
    local args = {ACTION, uid}
    local ok, err = pcall(function()
        if remote:IsA("RemoteFunction") then
            remote:InvokeServer(unpack(args))
        else
            remote:FireServer(unpack(args))
        end
    end)
    if ok then
        print(("Sent %d/%d -> %s"):format(i, #uuids, uid))
    else
        warn(("Failed to send for %s : %s"):format(uid, tostring(err)))
    end
    task.wait(0.08) -- short throttle
end

print("Finished sending Unvault for all detected UUIDs.")
